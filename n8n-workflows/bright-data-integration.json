{
  "name": "Bright Data LinkedIn Profile Enrichment",
  "nodes": [
    {
      "parameters": {},
      "id": "trigger-webhook",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [250, 300],
      "webhookId": "bright-data-enrichment",
      "credentials": {}
    },
    {
      "parameters": {
        "content": "## Input Validation\nValidates incoming LinkedIn URL and prepares for Bright Data API call",
        "height": 100,
        "width": 250
      },
      "id": "note-validation",
      "name": "Input Validation",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [200, 150]
    },
    {
      "parameters": {
        "jsCode": "// Validate and extract LinkedIn URL\nconst input = $input.first().json;\n\nif (!input.linkedinUrl) {\n  throw new Error('LinkedIn URL is required');\n}\n\nconst urlPattern = /^https?:\\/\\/(www\\.)?linkedin\\.com\\/in\\/[a-zA-Z0-9-]+\\/?/;\n\nif (!urlPattern.test(input.linkedinUrl)) {\n  throw new Error('Invalid LinkedIn URL format');\n}\n\n// Extract profile ID from URL\nconst profileId = input.linkedinUrl.match(/\\/in\\/([a-zA-Z0-9-]+)/)?.[1] || '';\n\n// Prepare request metadata\nreturn {\n  linkedinUrl: input.linkedinUrl,\n  profileId: profileId,\n  requestId: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n  timestamp: new Date().toISOString(),\n  source: input.source || 'manual',\n  priority: input.priority || 'normal',\n  webhookUrl: input.webhookUrl || null,\n  enrichmentOptions: {\n    includeActivity: input.includeActivity !== false,\n    includeCompanyDetails: input.includeCompanyDetails !== false,\n    includeMutualConnections: input.includeMutualConnections || false,\n    maxRetries: input.maxRetries || 3\n  }\n};"
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "content": "## Cache Check\nChecks if profile data exists in cache and is still fresh",
        "height": 100,
        "width": 250
      },
      "id": "note-cache",
      "name": "Cache Check",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [600, 150]
    },
    {
      "parameters": {
        "operation": "get",
        "propertyName": "cacheKey",
        "key": "={{ 'linkedin_profile_' + $json.profileId }}",
        "options": {
          "ttl": 604800
        }
      },
      "id": "redis-get",
      "name": "Check Redis Cache",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [650, 300],
      "credentials": {
        "redis": {
          "id": "redis-cache-creds",
          "name": "Redis Cache"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.cacheKey }}",
              "operation": "isEmpty"
            }
          ]
        }
      },
      "id": "cache-decision",
      "name": "Cache Hit?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [850, 300]
    },
    {
      "parameters": {
        "content": "## Bright Data API Call\nCalls Bright Data scraper API to get LinkedIn profile data",
        "height": 100,
        "width": 300
      },
      "id": "note-bright-data",
      "name": "Bright Data API",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1000, 150]
    },
    {
      "parameters": {
        "url": "https://api.brightdata.com/dca/trigger",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "brightDataApi",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "dataset_id",
              "value": "gd_l1viktl72bvl7bjuj0"
            },
            {
              "name": "url",
              "value": "={{ $json.linkedinUrl }}"
            },
            {
              "name": "format",
              "value": "json"
            },
            {
              "name": "webhook_url",
              "value": "={{ $json.webhookUrl || $env.N8N_WEBHOOK_BASE_URL + '/webhook/bright-data-callback' }}"
            },
            {
              "name": "include_errors",
              "value": true
            }
          ]
        },
        "options": {
          "timeout": 30000,
          "retry": {
            "retries": 3,
            "retryInterval": 2000
          }
        }
      },
      "id": "bright-data-api",
      "name": "Call Bright Data API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1050, 400],
      "credentials": {
        "brightDataApi": {
          "id": "bright-data-api",
          "name": "Bright Data API"
        }
      }
    },
    {
      "parameters": {
        "mode": "wait",
        "value": "={{ $json.enrichmentOptions.maxRetries * 5 }}",
        "unit": "seconds",
        "webhookUrl": "={{ $env.N8N_WEBHOOK_BASE_URL + '/webhook/bright-data-result/' + $json.requestId }}"
      },
      "id": "wait-for-result",
      "name": "Wait for Scraping Result",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [1250, 400]
    },
    {
      "parameters": {
        "content": "## Data Transformation\nTransforms raw Bright Data response to standardized format",
        "height": 100,
        "width": 300
      },
      "id": "note-transform",
      "name": "Transform Data",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1400, 150]
    },
    {
      "parameters": {
        "jsCode": "// Import transformer logic\nconst rawData = $input.first().json;\n\n// Transform Bright Data response to enriched profile format\nfunction transformProfile(raw) {\n  const profileId = extractProfileId(raw.url || '');\n  \n  return {\n    profileId: profileId,\n    lastUpdated: new Date().toISOString(),\n    dataSource: 'bright_data',\n    confidenceScore: calculateConfidence(raw),\n    completenessScore: calculateCompleteness(raw),\n    \n    basicInfo: {\n      fullName: raw.name || 'Unknown',\n      headline: raw.headline || '',\n      location: raw.location || '',\n      profileUrl: raw.url || '',\n      publicId: profileId,\n      profileImageUrl: raw.profile_image,\n      bannerImageUrl: raw.banner_image\n    },\n    \n    professional: {\n      currentPosition: {\n        title: raw.current_position?.title || '',\n        company: raw.current_position?.company || '',\n        startDate: raw.current_position?.start_date || '',\n        description: raw.current_position?.description\n      },\n      previousRoles: (raw.experience || []).slice(1).map(exp => ({\n        title: exp.title || '',\n        company: exp.company || '',\n        startDate: exp.start_date,\n        endDate: exp.end_date,\n        description: exp.description\n      })),\n      totalExperience: calculateTotalExperience(raw.experience || [])\n    },\n    \n    education: {\n      degrees: (raw.education || []).map(edu => ({\n        type: inferDegreeType(edu.degree || ''),\n        field: edu.field || edu.degree || '',\n        institution: edu.school || '',\n        graduationYear: edu.end_date\n      })),\n      certifications: (raw.certifications || []).map(cert => ({\n        name: cert.name || '',\n        issuer: cert.authority || '',\n        dateObtained: cert.date\n      }))\n    },\n    \n    skills: {\n      endorsed: raw.skills || [],\n      topSkills: (raw.skills || []).slice(0, 5)\n    },\n    \n    network: {\n      connectionsCount: raw.connections || 0,\n      followersCount: raw.followers || 0,\n      mutualConnections: raw.mutual_connections || []\n    },\n    \n    activity: {\n      lastActive: determineLastActive(raw.activity),\n      recentPosts: (raw.activity?.posts || []).slice(0, 5),\n      publishedArticles: raw.activity?.articles || []\n    },\n    \n    companyIntelligence: {\n      currentCompany: {\n        name: raw.company_details?.name || raw.current_position?.company || '',\n        size: raw.company_details?.size,\n        industry: raw.company_details?.industry,\n        type: raw.company_details?.type,\n        headquarters: raw.company_details?.headquarters,\n        website: raw.company_details?.website\n      }\n    },\n    \n    enrichmentMetadata: {\n      scraperVersion: '1.0.0',\n      extractionTimestamp: new Date().toISOString(),\n      dataPoints: countDataPoints(raw),\n      missingFields: findMissingFields(raw),\n      enrichmentCost: 0.08,\n      processingTime: Date.now() - new Date($json.timestamp).getTime()\n    }\n  };\n}\n\n// Helper functions\nfunction extractProfileId(url) {\n  const match = url.match(/linkedin\\.com\\/in\\/([^\\/?]+)/);\n  return match ? match[1] : `profile_${Date.now()}`;\n}\n\nfunction calculateConfidence(raw) {\n  let score = 50;\n  if (raw.name) score += 10;\n  if (raw.headline) score += 10;\n  if (raw.current_position?.title) score += 10;\n  if ((raw.experience || []).length > 2) score += 10;\n  if ((raw.skills || []).length > 5) score += 10;\n  return Math.min(score, 100);\n}\n\nfunction calculateCompleteness(raw) {\n  const fields = [\n    raw.name, raw.headline, raw.location, raw.summary,\n    raw.current_position?.title, raw.experience?.length,\n    raw.education?.length, raw.skills?.length\n  ];\n  const filled = fields.filter(f => f).length;\n  return Math.round((filled / fields.length) * 100);\n}\n\nfunction calculateTotalExperience(experiences) {\n  let months = 0;\n  experiences.forEach(exp => {\n    if (exp.start_date) {\n      const start = new Date(exp.start_date);\n      const end = exp.end_date ? new Date(exp.end_date) : new Date();\n      months += Math.round((end - start) / (1000 * 60 * 60 * 24 * 30));\n    }\n  });\n  return months;\n}\n\nfunction inferDegreeType(degree) {\n  const lower = degree.toLowerCase();\n  if (lower.includes('phd') || lower.includes('doctor')) return 'PhD';\n  if (lower.includes('master') || lower.includes('mba')) return 'Masters';\n  if (lower.includes('bachelor')) return 'Bachelors';\n  return 'Certificate';\n}\n\nfunction determineLastActive(activity) {\n  if (!activity) return null;\n  const posts = activity.posts || [];\n  if (posts.length > 0) return posts[0].date;\n  return null;\n}\n\nfunction countDataPoints(raw) {\n  let count = 0;\n  const fields = [\n    'name', 'headline', 'location', 'summary', 'current_position',\n    'experience', 'education', 'skills', 'connections', 'followers',\n    'profile_image', 'company_details', 'activity', 'certifications'\n  ];\n  fields.forEach(field => {\n    if (raw[field]) count++;\n  });\n  return count;\n}\n\nfunction findMissingFields(raw) {\n  const missing = [];\n  if (!raw.name) missing.push('name');\n  if (!raw.headline) missing.push('headline');\n  if (!raw.current_position?.title) missing.push('current_position');\n  if (!raw.skills?.length) missing.push('skills');\n  if (!raw.experience?.length) missing.push('experience');\n  return missing;\n}\n\n// Process the response\nif (rawData.error) {\n  throw new Error(`Bright Data API error: ${rawData.error}`);\n}\n\nconst transformedProfile = transformProfile(rawData);\n\n// Add original request metadata\ntransformedProfile.requestMetadata = {\n  requestId: $json.requestId,\n  originalUrl: $json.linkedinUrl,\n  source: $json.source,\n  priority: $json.priority\n};\n\nreturn transformedProfile;"
      },
      "id": "transform-data",
      "name": "Transform Bright Data Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1450, 400]
    },
    {
      "parameters": {
        "content": "## Cache Storage\nStores enriched profile in Redis cache",
        "height": 100,
        "width": 250
      },
      "id": "note-store-cache",
      "name": "Store in Cache",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1600, 150]
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ 'linkedin_profile_' + $json.profileId }}",
        "value": "={{ JSON.stringify($json) }}",
        "expire": true,
        "ttl": 604800
      },
      "id": "redis-set",
      "name": "Store in Redis Cache",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1650, 400],
      "credentials": {
        "redis": {
          "id": "redis-cache-creds",
          "name": "Redis Cache"
        }
      }
    },
    {
      "parameters": {
        "content": "## Quality Check\nValidates data quality and completeness",
        "height": 100,
        "width": 250
      },
      "id": "note-quality",
      "name": "Quality Check",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1800, 150]
    },
    {
      "parameters": {
        "jsCode": "// Validate transformed data quality\nconst profile = $input.first().json;\n\nconst validation = {\n  isValid: true,\n  errors: [],\n  warnings: [],\n  qualityScore: 0\n};\n\n// Critical validations\nif (!profile.profileId) {\n  validation.errors.push('Missing profile ID');\n  validation.isValid = false;\n}\n\nif (!profile.basicInfo?.fullName || profile.basicInfo.fullName === 'Unknown') {\n  validation.errors.push('Missing or unknown full name');\n  validation.isValid = false;\n}\n\nif (!profile.basicInfo?.profileUrl) {\n  validation.errors.push('Missing profile URL');\n  validation.isValid = false;\n}\n\n// Quality checks\nif (profile.completenessScore < 30) {\n  validation.warnings.push(`Low completeness score: ${profile.completenessScore}%`);\n}\n\nif (profile.confidenceScore < 40) {\n  validation.warnings.push(`Low confidence score: ${profile.confidenceScore}%`);\n}\n\nif (!profile.professional?.currentPosition?.title) {\n  validation.warnings.push('No current position found');\n}\n\nif ((profile.skills?.endorsed || []).length < 3) {\n  validation.warnings.push('Limited skills data');\n}\n\nif ((profile.professional?.previousRoles || []).length === 0) {\n  validation.warnings.push('No work history found');\n}\n\n// Calculate quality score\nlet qualityScore = 50;\nif (profile.completenessScore > 70) qualityScore += 15;\nif (profile.confidenceScore > 70) qualityScore += 15;\nif ((profile.skills?.endorsed || []).length > 5) qualityScore += 10;\nif ((profile.professional?.previousRoles || []).length > 2) qualityScore += 10;\n\nvalidation.qualityScore = Math.min(qualityScore, 100);\n\n// Add validation results to profile\nprofile.validation = validation;\n\n// Decide if we should retry with fallback\nif (!validation.isValid && profile.enrichmentMetadata.dataSource === 'bright_data') {\n  profile.requiresFallback = true;\n}\n\nreturn profile;"
      },
      "id": "validate-quality",
      "name": "Validate Data Quality",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1850, 400]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.requiresFallback }}",
              "value2": true
            }
          ]
        }
      },
      "id": "fallback-check",
      "name": "Needs Fallback?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2050, 400]
    },
    {
      "parameters": {
        "content": "## Fallback Scraper\nUses Apify as fallback when Bright Data fails",
        "height": 100,
        "width": 250
      },
      "id": "note-fallback",
      "name": "Fallback",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [2200, 250]
    },
    {
      "parameters": {
        "url": "https://api.apify.com/v2/acts/apify~linkedin-profile-scraper/run-sync",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "apifyApi",
        "method": "POST",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "profileUrls",
              "value": "={{ [$json.basicInfo.profileUrl] }}"
            },
            {
              "name": "proxyConfiguration",
              "value": {
                "useApifyProxy": true
              }
            }
          ]
        },
        "options": {
          "timeout": 60000
        }
      },
      "id": "apify-fallback",
      "name": "Apify Fallback Scraper",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2250, 500],
      "credentials": {
        "apifyApi": {
          "id": "apify-api",
          "name": "Apify API"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "content": "## Store Results\nSaves enriched profile to Google Sheets",
        "height": 100,
        "width": 250
      },
      "id": "note-store",
      "name": "Store Results",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [2400, 150]
    },
    {
      "parameters": {
        "operation": "append",
        "sheetId": "={{ $env.GOOGLE_SHEET_ID }}",
        "range": "EnrichedProfiles!A:Z",
        "options": {
          "valueInputMode": "USER_ENTERED"
        },
        "values": [
          [
            "={{ $json.profileId }}",
            "={{ $json.basicInfo.fullName }}",
            "={{ $json.basicInfo.headline }}",
            "={{ $json.basicInfo.location }}",
            "={{ $json.basicInfo.profileUrl }}",
            "={{ $json.professional.currentPosition.title }}",
            "={{ $json.professional.currentPosition.company }}",
            "={{ $json.professional.totalExperience }}",
            "={{ $json.skills.endorsed.join(', ') }}",
            "={{ $json.education.degrees[0]?.institution || '' }}",
            "={{ $json.network.connectionsCount }}",
            "={{ $json.network.followersCount }}",
            "={{ $json.companyIntelligence.currentCompany.name }}",
            "={{ $json.companyIntelligence.currentCompany.size }}",
            "={{ $json.companyIntelligence.currentCompany.industry }}",
            "={{ $json.completenessScore }}",
            "={{ $json.confidenceScore }}",
            "={{ $json.validation.qualityScore }}",
            "={{ $json.dataSource }}",
            "={{ $json.lastUpdated }}",
            "={{ JSON.stringify($json) }}"
          ]
        ]
      },
      "id": "google-sheets-store",
      "name": "Store in Google Sheets",
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 2,
      "position": [2450, 400],
      "credentials": {
        "googleSheetsApi": {
          "id": "google-sheets-api",
          "name": "Google Sheets API"
        }
      }
    },
    {
      "parameters": {
        "content": "## Send Metrics\nTracks enrichment metrics and costs",
        "height": 100,
        "width": 250
      },
      "id": "note-metrics",
      "name": "Send Metrics",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [2600, 150]
    },
    {
      "parameters": {
        "jsCode": "// Prepare metrics for monitoring dashboard\nconst profile = $input.first().json;\n\nconst metrics = {\n  timestamp: new Date().toISOString(),\n  requestId: profile.requestMetadata?.requestId,\n  profileId: profile.profileId,\n  \n  // Success metrics\n  enrichmentSuccess: profile.validation?.isValid || false,\n  dataSource: profile.dataSource,\n  fallbackUsed: profile.dataSource === 'apify',\n  \n  // Quality metrics\n  completenessScore: profile.completenessScore,\n  confidenceScore: profile.confidenceScore,\n  qualityScore: profile.validation?.qualityScore || 0,\n  dataPoints: profile.enrichmentMetadata?.dataPoints || 0,\n  missingFields: profile.enrichmentMetadata?.missingFields || [],\n  \n  // Performance metrics\n  processingTime: profile.enrichmentMetadata?.processingTime || 0,\n  cacheHit: false, // Will be true when coming from cache branch\n  \n  // Cost metrics\n  enrichmentCost: profile.enrichmentMetadata?.enrichmentCost || 0,\n  \n  // Data richness\n  hasCurrentPosition: !!profile.professional?.currentPosition?.title,\n  experienceCount: (profile.professional?.previousRoles || []).length,\n  skillsCount: (profile.skills?.endorsed || []).length,\n  educationCount: (profile.education?.degrees || []).length,\n  hasCompanyIntel: !!profile.companyIntelligence?.currentCompany?.industry,\n  hasActivity: (profile.activity?.recentPosts || []).length > 0,\n  \n  // Validation details\n  errors: profile.validation?.errors || [],\n  warnings: profile.validation?.warnings || []\n};\n\nreturn metrics;"
      },
      "id": "prepare-metrics",
      "name": "Prepare Metrics",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2650, 400]
    },
    {
      "parameters": {
        "url": "={{ $env.MONITORING_WEBHOOK_URL || 'http://localhost:3000/metrics/enrichment' }}",
        "method": "POST",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "X-Source",
              "value": "n8n-bright-data"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json) }}",
        "options": {
          "timeout": 5000
        }
      },
      "id": "send-metrics",
      "name": "Send to Monitoring",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2850, 400],
      "continueOnFail": true
    },
    {
      "parameters": {
        "values": {
          "boolean": [
            {
              "name": "success",
              "value": "={{ $json.validation?.isValid || false }}"
            }
          ],
          "string": [
            {
              "name": "profileId",
              "value": "={{ $json.profileId }}"
            },
            {
              "name": "message",
              "value": "={{ $json.validation?.isValid ? 'Profile enriched successfully' : 'Enrichment completed with warnings' }}"
            }
          ],
          "number": [
            {
              "name": "completenessScore",
              "value": "={{ $json.completenessScore }}"
            },
            {
              "name": "qualityScore",
              "value": "={{ $json.validation?.qualityScore || 0 }}"
            }
          ]
        },
        "options": {}
      },
      "id": "format-response",
      "name": "Format Response",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [3050, 400]
    },
    {
      "parameters": {
        "jsCode": "// Return cached data\nconst cached = JSON.parse($json.cacheKey);\n\n// Update cache metadata\ncached.enrichmentMetadata = cached.enrichmentMetadata || {};\ncached.enrichmentMetadata.servedFromCache = true;\ncached.enrichmentMetadata.cacheTimestamp = new Date().toISOString();\n\nreturn cached;"
      },
      "id": "return-cached",
      "name": "Return Cached Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 200]
    },
    {
      "parameters": {
        "content": "## Error Handling\nHandles API errors and failures",
        "height": 100,
        "width": 250
      },
      "id": "note-error",
      "name": "Error Handling",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [1050, 550]
    },
    {
      "parameters": {
        "jsCode": "// Error handler for Bright Data API failures\nconst error = $input.first().error;\nconst originalRequest = $json;\n\nconst errorLog = {\n  timestamp: new Date().toISOString(),\n  requestId: originalRequest.requestId,\n  linkedinUrl: originalRequest.linkedinUrl,\n  errorType: 'bright_data_api_error',\n  errorMessage: error?.message || 'Unknown error',\n  errorCode: error?.code,\n  willRetry: true,\n  retryCount: originalRequest.retryCount || 0,\n  maxRetries: originalRequest.enrichmentOptions?.maxRetries || 3\n};\n\n// Log error to monitoring\nawait $http.post(process.env.MONITORING_WEBHOOK_URL + '/errors', errorLog).catch(() => {});\n\n// Decide if we should retry or fallback\nif (errorLog.retryCount < errorLog.maxRetries) {\n  // Prepare for retry\n  return {\n    ...originalRequest,\n    retryCount: errorLog.retryCount + 1,\n    shouldRetry: true\n  };\n} else {\n  // Max retries reached, use fallback\n  return {\n    ...originalRequest,\n    shouldUseFallback: true,\n    brightDataFailed: true\n  };\n}"
      },
      "id": "handle-error",
      "name": "Handle API Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1250, 550],
      "executeOnce": false,
      "continueOnFail": true
    }
  ],
  "connections": {
    "trigger-webhook": {
      "main": [
        [
          {
            "node": "validate-input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "validate-input": {
      "main": [
        [
          {
            "node": "redis-get",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "redis-get": {
      "main": [
        [
          {
            "node": "cache-decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "cache-decision": {
      "main": [
        [
          {
            "node": "bright-data-api",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "return-cached",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "bright-data-api": {
      "main": [
        [
          {
            "node": "wait-for-result",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "handle-error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "wait-for-result": {
      "main": [
        [
          {
            "node": "transform-data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "transform-data": {
      "main": [
        [
          {
            "node": "redis-set",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "redis-set": {
      "main": [
        [
          {
            "node": "validate-quality",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "validate-quality": {
      "main": [
        [
          {
            "node": "fallback-check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "fallback-check": {
      "main": [
        [
          {
            "node": "apify-fallback",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "google-sheets-store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "apify-fallback": {
      "main": [
        [
          {
            "node": "google-sheets-store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "google-sheets-store": {
      "main": [
        [
          {
            "node": "prepare-metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "prepare-metrics": {
      "main": [
        [
          {
            "node": "send-metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "send-metrics": {
      "main": [
        [
          {
            "node": "format-response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "return-cached": {
      "main": [
        [
          {
            "node": "prepare-metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "handle-error": {
      "main": [
        [
          {
            "node": "apify-fallback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "saveDataErrorExecution": "all",
    "saveDataSuccessExecution": "all",
    "callerPolicy": "workflowsFromSameOwner",
    "timezone": "America/New_York",
    "errorWorkflow": "bright-data-error-handler"
  }
}